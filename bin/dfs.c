#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

////////////////////////////
//    - Movement Code -   //
// 1 : Left								//
// 2 : Forward						//
// 3 : Right							//
// 4 : Back								//
//												//
////////////////////////////

///////////////////////////////////////////////////////////////////
//                  Constants & Function                         //
///////////////////////////////////////////////////////////////////

///////////////
// Constants //
///////////////
// Macro Define
#define max_stack 200

// Constants
const int track_speed = 50;
const int encode_range = 200;

// Stack
typedef struct{
	int data[max_stack];
	int top_stack;
} Stack;

///////////////
// Functions //
///////////////

// Stack Primitives
void CreateStack(Stack * S);
void Push(Stack * S, int i);
int Pop(Stack * S);

// Color Check
bool isSameColor(int color);
int lineTrack();

// Turn L/R
void turnL(int deg);
void turnR(int deg);

// Debugger
void PrintOutput(Stack S);

//Output
void ClearOutput();

///////////////////////////////////////////////////////////////////
//                         Main Program                          //
///////////////////////////////////////////////////////////////////

task main()
{
	////////////////////
	// Init Variables //
	////////////////////
	bool finish = false;
	bool u_turn = false;
	bool found_green = false;
	int block_found;
	int i;
	Stack S;

	CreateStack(&S);


	///////////////
	//   START   //
	///////////////

	// Start movement, find the start line
	setMotor(leftMotor,50);
	setMotor(rightMotor,50);
	waitUntil(isSameColor(colorBlue));
	waitUntil(isSameColor(colorBlack));

	// Start tracking
	while(!finish){

		///////////////////
		// Line tracking //
		///////////////////

		block_found = lineTrack();
		// Reset motor Encoder
		resetMotorEncoder(leftMotor);
		resetMotorEncoder(rightMotor);
		//Found Green
		if(block_found == 0){

			///////////////
			// Start DFS //
			///////////////

			//Check branch
			setMotor(leftMotor,50);
			setMotor(rightMotor,50);
			waitUntil(!isSameColor(colorGreen) && (getMotorEncoder(leftMotor)> encode_range));
			stopAllMotors();
			turnL(90);

			// Check whether a red block has been encountered
			// If so, add the last value to switch to another
			// branch.
			if(!u_turn){
				i = 1;
			}
			else{
				if(i <= 3){
					i++;
				}
				else{
					i = Pop(&S);
					i++;
				}
				u_turn = false;
			}

			Push(&S,i);

			// After turning, check for branch availability
			while(getColorAmbient(colorSensor) >= 90 && i <= 3){
				// Change movement, on unavailable branch
				i = Pop(&S);
				i++;
				Push(&S, i);
				turnR(90);
			}
			// EXCEPTION : Found Green Zone again
			clearTimer(T1);
			found_green = true;
		}

		// Found Red
		else if(block_found == 1){
			// Dead End, turn around, signal that a u turn
			// has been encountered
			i = Pop(&S);
			u_turn = true;
			setMotor(leftMotor,50);
			setMotor(rightMotor,50);
			waitUntil(!isSameColor(colorRed) && getMotorEncoder(leftMotor)>encode_range);
			stopAllMotors();
			turnL(180);
		}

		// Found Yellow
		else if(block_found == 2){
			// Found the end, start tracing back steps
			setMotor(leftMotor,50);
			setMotor(rightMotor,50);
			waitUntil(!isSameColor(colorYellow));
			ClearOutput();
			displayTextLine(5, "DONE! Backtracking");
			stopAllMotors();
			wait(2);
			finish = true;
		}
		PrintOutput(S);
	}

	///////////////
	// Backtrack //
	///////////////
	// Initialize variables
	block_found = 0;

	// Turn around
	turnL(180);
	while(block_found != 3){
		block_found = lineTrack();

		// if encountered an intersection, do the
		if (block_found == 0){
			//Move a bit
			resetMotorEncoder(leftMotor);
			resetMotorEncoder(rightMotor);
			setMotor(leftMotor,50);
			setMotor(rightMotor,50);
			waitUntil(!isSameColor(colorGreen) && getMotorEncoder(leftMotor) >= encode_range);

			//Decide home movement
			i = (Pop(&S) + 2) % 4;
			if(i == 1){
				turnL(90);
			}
			else if (i == 3){
				turnR(90);
			}
			PrintOutput(S);
		}
	}
	ClearOutput();
	displayTextLine(i, "Exit Reached");
}




///////////////////////////////////////////////////////////////////
//                     Function Implementation                   //
///////////////////////////////////////////////////////////////////

bool isSameColor(int color){
	return (getColorName(colorSensor) == color);
}

// Melakukan tracking dan menghasilkan int dengan nilai tertentu
// jika menemukan warna berikut
// 0 = Green
// 1 = Red
// 2 = Yellow
int lineTrack(){
	int retval;
	bool exit = false;
	while (!exit){
		if(isSameColor(colorBlack)){
			setMotor(rightMotor, 0);
			setMotor(leftMotor, track_speed);
		}
		else if(isSameColor(colorWhite)){
			setMotor(rightMotor, track_speed);
			setMotor(leftMotor, 0);
		}
		//Branch found
		else if(isSameColor(colorGreen)){
			exit = true;
			stopAllMotors();
			retval = 0;
		}
		else if(isSameColor(colorRed)){
			exit = true;
			stopAllMotors();
			retval = 1;
		}
		else if(isSameColor(colorYellow)){
			exit = true;
			stopAllMotors();
			retval = 2;
		}
		else if(isSameColor(colorBlue)){
			exit = true;
			stopAllMotors();
			retval = 3;
		}
	}
	return retval;
}

void turnR(int deg){
	string sOutputString;
	resetGyro(gyroSensor);
	setMotor(leftMotor,50);
	setMotor(rightMotor,-50);
	while(getGyroDegrees(gyroSensor) < deg){	}
	stopAllMotors();
}

void turnL(int deg){
	string sOutputString;

	resetGyro(gyroSensor);
	setMotor(leftMotor,-50);
	setMotor(rightMotor,50);
	while(getGyroDegrees(gyroSensor) > -deg){
	}
	stopAllMotors();
}

void CreateStack(Stack * S){
	int i;
	(*S).top_stack = -1;
	for (i = 0; i < max_stack; i++){
		(*S).data[i] = 0;
	}
}

void Push(Stack * S, int i){
	(*S).top_stack++;
	(*S).data[(*S).top_stack] = i;
}

int Pop(Stack * S){
	int i;
	i = (*S).data[(*S).top_stack];
	(*S).data[(*S).top_stack] = 0;
	(*S).top_stack--;

	return i;
}
void PrintOutput(Stack S){
	int i;
	string Output;
	if(S.top_stack >= 0){
		for(i = 0; i <= S.top_stack; i++){
			sprintf(Output, "%d", S.data[i]);
			displayTextLine(i, Output);
		}
	}
}

void ClearOutput(){
	int i;
	for(i = 0; i <= 7; i++){
		displayTextLine(i, "");
	}
}
